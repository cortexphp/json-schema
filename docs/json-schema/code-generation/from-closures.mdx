---
title: From Closures
description: 'Generate JSON schemas from PHP function signatures and docblocks'
icon: 'parentheses'
---

Generate JSON schemas automatically from PHP closures (anonymous functions) and function signatures. This feature analyzes function parameters, types, and docblocks to create comprehensive validation schemas.

## Basic Closure Schema Generation

Generate a schema from a simple closure:

```php
use Cortex\JsonSchema\Schema;

/**
 * Process user registration data
 *
 * @param string $name The user's full name
 * @param string $email The user's email address
 * @param int $age The user's age in years
 */
$registrationClosure = function (string $name, string $email, int $age): void {
    // Process registration...
};

// Generate schema from closure
$schema = Schema::fromClosure($registrationClosure);

// Convert to JSON Schema
$jsonSchema = $schema->toJson(JSON_PRETTY_PRINT);
```

<Accordion title="View Generated JSON Schema">
```json
{
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "type": "object",
    "description": "Process user registration data",
    "properties": {
        "name": {
            "type": "string",
            "description": "The user's full name"
        },
        "email": {
            "type": "string",
            "description": "The user's email address"
        },
        "age": {
            "type": "integer",
            "description": "The user's age in years"
        }
    },
    "required": ["name", "email", "age"]
}
```
</Accordion>

## Optional Parameters and Default Values

Handle optional parameters with default values:

```php
/**
 * Create a new product listing
 *
 * @param string $name Product name
 * @param float $price Product price in USD
 * @param string $description Product description
 * @param bool $active Whether the product is active
 * @param array $tags Product tags
 */
$createProductClosure = function (
    string $name,
    float $price,
    string $description = '',
    bool $active = true,
    array $tags = []
): void {
    // Create product...
};

$schema = Schema::fromClosure($createProductClosure);
```

<Accordion title="View Generated JSON Schema">
```json
{
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "type": "object",
    "description": "Create a new product listing",
    "properties": {
        "name": {
            "type": "string",
            "description": "Product name"
        },
        "price": {
            "type": "number",
            "description": "Product price in USD"
        },
        "description": {
            "type": "string",
            "description": "Product description",
            "default": ""
        },
        "active": {
            "type": "boolean",
            "description": "Whether the product is active",
            "default": true
        },
        "tags": {
            "type": "array",
            "description": "Product tags",
            "default": []
        }
    },
    "required": ["name", "price"]
}
```
</Accordion>

## Nullable Parameters

Handle nullable and union types:

```php
/**
 * Update user profile information
 *
 * @param string $user_id The user's unique identifier
 * @param ?string $name The user's name (null to keep current)
 * @param ?string $email The user's email (null to keep current)
 * @param ?int $age The user's age (null to keep current)
 * @param ?array $preferences User preferences (null to keep current)
 */
$updateUserClosure = function (
    string $user_id,
    ?string $name = null,
    ?string $email = null,
    ?int $age = null,
    ?array $preferences = null
): void {
    // Update user...
};

$schema = Schema::fromClosure($updateUserClosure);
```

The generated schema will include nullable types:

<Accordion title="View Generated JSON Schema">
```json
{
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "type": "object",
    "properties": {
        "user_id": {
            "type": "string",
            "description": "The user's unique identifier"
        },
        "name": {
            "type": ["string", "null"],
            "description": "The user's name (null to keep current)",
            "default": null
        },
        "email": {
            "type": ["string", "null"],
            "description": "The user's email (null to keep current)",
            "default": null
        },
        "age": {
            "type": ["integer", "null"],
            "description": "The user's age (null to keep current)",
            "default": null
        },
        "preferences": {
            "type": ["array", "null"],
            "description": "User preferences (null to keep current)",
            "default": null
        }
    },
    "required": ["user_id"]
}
```
</Accordion>

## Advanced Parameter Documentation

Use detailed docblock annotations for validation rules:

```php
/**
 * Process payment transaction
 *
 * Handles payment processing with validation and security checks.
 *
 * @param string $payment_method Payment method type
 * @param float $amount Transaction amount
 * @param string $currency Currency code
 * @param string $customer_email Customer email address
 * @param array $billing_address Billing address information
 * @param ?string $description Transaction description
 */
$processPaymentClosure = function (
    string $payment_method,     // credit_card, paypal, bank_transfer
    float $amount,              // Must be positive, up to 2 decimal places
    string $currency,           // 3-letter ISO currency code
    string $customer_email,     // Valid email format
    array $billing_address,     // Address components
    ?string $description = null // Optional transaction notes
): array {
    // Process payment and return result
    return ['status' => 'success', 'transaction_id' => 'txn_123'];
};

// Generate with advanced validation rules
$schema = Schema::fromClosure($processPaymentClosure);
```

## Complex Parameter Types

Handle complex array and object types:

```php
/**
 * Create order with complex item structure
 *
 * @param string $customer_id Customer identifier
 * @param array $items Order items with product details
 *   Each item should have: product_id, quantity, unit_price
 * @param array $shipping_address Shipping address
 *   Should include: street, city, state, postal_code, country
 * @param ?array $billing_address Billing address (optional, uses shipping if null)
 * @param array $metadata Additional order metadata
 */
$createOrderClosure = function (
    string $customer_id,
    array $items,
    array $shipping_address,
    ?array $billing_address = null,
    array $metadata = []
): string {
    // Create order and return order ID
    return 'order_123';
};

$schema = Schema::fromClosure($createOrderClosure);
```

## API Endpoint Schema Generation

Real-world example for API endpoint validation:

```php
/**
 * API endpoint for user search
 *
 * Searches for users based on various criteria with pagination support.
 *
 * @param ?string $query Search query string
 * @param ?string $email Email filter
 * @param ?int $age_min Minimum age filter
 * @param ?int $age_max Maximum age filter
 * @param array $roles Role filter
 * @param int $page Page number for pagination
 * @param int $per_page Items per page
 * @param string $sort_by Sort field
 * @param string $sort_direction Sort direction
 * @param bool $include_inactive Include inactive users
 */
$userSearchClosure = function (
    ?string $query = null,
    ?string $email = null,
    ?int $age_min = null,
    ?int $age_max = null,
    array $roles = [],
    int $page = 1,
    int $per_page = 20,
    string $sort_by = 'name',
    string $sort_direction = 'asc',
    bool $include_inactive = false
): array {
    // Perform search and return results
    return [
        'users' => [],
        'pagination' => [
            'page' => $page,
            'per_page' => $per_page,
            'total' => 0
        ]
    ];
};

$searchSchema = Schema::fromClosure($userSearchClosure);
```

## Schema Versioning

Generate schemas for different JSON Schema versions:

```php
use Cortex\JsonSchema\Enums\SchemaVersion;

/**
 * Modern API endpoint with deprecated parameters
 *
 * @param string $data Main data parameter
 * @param ?string $legacy_param Legacy parameter
 * @param array $tags Data tags
 */
$modernApiClosure = function (
    string $data,
    ?string $legacy_param = null,
    array $tags = []
): void {
    // Process modern API request
};

// Generate with Draft 2019-09 for deprecated support
$modernSchema = Schema::fromClosure(
    $modernApiClosure,
    version: SchemaVersion::Draft_2019_09
);

// Apply validation rules programmatically after generation
$modernSchema->properties(
    Schema::array('tags')
        ->minContains(1)
        ->maxContains(5)
);
```

## Validation and Testing

Use generated schemas to validate function inputs:

```php
// Define the function
/**
 * Process contact form submission
 *
 * @param string $name Contact name
 * @param string $email Contact email
 * @param string $subject Message subject
 * @param string $message Message content
 * @param ?string $phone Contact phone number
 */
$contactFormClosure = function (
    string $name,
    string $email,
    string $subject,
    string $message,
    ?string $phone = null
): bool {
    // Process contact form
    return true;
};

// Generate validation schema
$contactSchema = Schema::fromClosure($contactFormClosure);

// Validate form data
$formData = [
    'name' => 'John Doe',
    'email' => 'john@example.com',
    'subject' => 'Website Inquiry',
    'message' => 'I would like more information about your services.',
    'phone' => '+1-555-123-4567'
];

if ($contactSchema->isValid($formData)) {
    // Call the function with validated data
    $result = $contactFormClosure(
        $formData['name'],
        $formData['email'],
        $formData['subject'],
        $formData['message'],
        $formData['phone'] ?? null
    );
    echo "Contact form processed successfully";
} else {
    try {
        $contactSchema->validate($formData);
    } catch (SchemaException $e) {
        echo "Validation error: " . $e->getMessage();
    }
}
```

## Best Practices

### 1. Write Comprehensive Function Documentation

```php
/**
 * Clear, descriptive function purpose
 *
 * Detailed explanation of what the function does,
 * including any important business logic or constraints.
 *
 * @param string $param Clear parameter description
 * @param int $number Numeric parameter with business meaning
 */
$wellDocumentedFunction = function (string $param, int $number): void {};
```

### 2. Use Type Hints Extensively

```php
// Good: Clear type information
function processData(
    string $name,           // Required string
    ?int $age = null,       // Optional integer
    array $tags = [],       // Array with default
    ?DateTime $date = null  // Optional DateTime
): bool {}

// Avoid: Missing type information
function processData($name, $age, $tags, $date) {}
```

### 3. Write Clear Documentation

```php
/**
 * @param string $email Email address
 * @param string $password Password
 */
```

<Note>
Validation rules like format, minLength, pattern are not extracted from docblocks. Generic array syntax (e.g., `array<string>`, `array<OrderItem>`) in docblocks is not parsed - arrays are treated as generic arrays without item type information. Only parameter types and descriptions are extracted. Apply validation rules and array item schemas programmatically using the fluent API after schema generation.
</Note>

### 4. Design Functions for Schema Generation

```php
// Good: Single responsibility, clear parameters
function createUser(string $name, string $email, int $age): User {}
function updateUser(string $id, ?string $name, ?string $email): bool {}

// Avoid: Complex, multi-purpose functions
function handleUserStuff($data, $action, $options = []) {}
```

## Supported Parameter Types

| PHP Type | JSON Schema Type | Notes |
|----------|------------------|-------|
| `string` | `string` | Basic string type |
| `int` | `integer` | Integer numbers |
| `float` | `number` | Floating-point numbers |
| `bool` | `boolean` | Boolean true/false |
| `array` | `array` | Generic arrays |
| `?string` | `["string", "null"]` | Nullable string |
| `mixed` | No type constraint | Accepts any type |
| `object` | `object` | Generic object |
| Custom classes | `object` | With class-specific properties |

## Common Use Cases

<CardGroup cols={2}>
  <Card title="API Validation" icon="server">
    Generate request validation schemas for API endpoints and microservices.
  </Card>
  <Card title="Form Processing" icon="file-text">
    Create client-side validation from server-side form processing functions.
  </Card>
  <Card title="Data Pipeline" icon="workflow">
    Validate data transformations and processing steps in data pipelines.
  </Card>
  <Card title="Configuration" icon="cog">
    Generate validation for configuration and setup functions.
  </Card>
</CardGroup>
