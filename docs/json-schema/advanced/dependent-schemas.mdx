---
title: Dependent Schemas
description: 'Property-dependent validation with dependent schemas in modern JSON Schema'
icon: 'shield-ban'
---

<Note>
Dependent schemas are an advanced feature available in JSON Schema Draft 2019-09 and later. They allow you to apply different validation rules based on the presence or values of specific properties.
</Note>

Dependent schemas provide a powerful way to create conditional validation based on property presence, replacing and expanding upon the `dependencies` keyword from earlier JSON Schema versions.

## Basic Dependent Schema

Define validation that depends on the presence of a property:

```php
use Cortex\JsonSchema\Schema;
use Cortex\JsonSchema\Enums\SchemaVersion;
use Cortex\JsonSchema\Enums\SchemaFormat;

$paymentSchema = Schema::object('payment', SchemaVersion::Draft_2019_09)
    ->properties(
        Schema::string('amount')->required(),
        Schema::string('method')->enum(['card', 'bank', 'paypal']),
        Schema::string('card_number'),
        Schema::string('bank_account'),
        Schema::string('paypal_email')
    )
    // When 'method' property is present, apply additional validation
    ->dependentSchema('method',
        Schema::object()
            ->if(Schema::object()->properties(
                Schema::string('method')->const('card')
            ))
            ->then(Schema::object()->properties(
                Schema::string('card_number')
                    ->pattern('^\d{16}$')
                    ->required()
            ))
            ->if(Schema::object()->properties(
                Schema::string('method')->const('bank')
            ))
            ->then(Schema::object()->properties(
                Schema::string('bank_account')
                    ->pattern('^\d{8,20}$')
                    ->required()
            ))
            ->if(Schema::object()->properties(
                Schema::string('method')->const('paypal')
            ))
            ->then(Schema::object()->properties(
                Schema::string('paypal_email')
                    ->format(SchemaFormat::Email)
                    ->required()
            ))
    );

// Valid card payment
$paymentSchema->isValid([
    'amount' => '100.00',
    'method' => 'card',
    'card_number' => '1234567890123456'
]); // true

// Invalid card payment - missing card number
$paymentSchema->isValid([
    'amount' => '100.00',
    'method' => 'card'
    // Missing required card_number
]); // false
```

<Accordion title="View JSON Schema Output">
```json
{
    "$schema": "https://json-schema.org/draft/2019-09/schema",
    "type": "object",
    "title": "payment",
    "properties": {
        "amount": {
            "type": "string"
        },
        "method": {
            "type": "string",
            "enum": ["card", "bank", "paypal"]
        },
        "card_number": {
            "type": "string"
        },
        "bank_account": {
            "type": "string"
        },
        "paypal_email": {
            "type": "string"
        }
    },
    "required": ["amount"],
    "dependentSchemas": {
        "method": {
            "type": "object",
            "if": {
                "type": "object",
                "properties": {
                    "method": {
                        "const": "card"
                    }
                }
            },
            "then": {
                "type": "object",
                "properties": {
                    "card_number": {
                        "type": "string",
                        "pattern": "^\\d{16}$"
                    }
                },
                "required": ["card_number"]
            }
        }
    }
}
```
</Accordion>

## Multiple Dependent Schemas

Apply different schemas based on multiple property dependencies:

```php
$userRegistrationSchema = Schema::object('registration', SchemaVersion::Draft_2019_09)
    ->properties(
        Schema::string('username')->required(),
        Schema::string('email')->required(),
        Schema::string('account_type')->enum(['personal', 'business']),
        Schema::boolean('newsletter_signup'),
        Schema::string('company_name'),
        Schema::string('tax_id'),
        Schema::string('marketing_source')
    )
    ->dependentSchemas([
        // Business account requirements
        'account_type' => Schema::object()
            ->if(Schema::object()->properties(
                Schema::string('account_type')->const('business')
            ))
            ->then(Schema::object()->properties(
                Schema::string('company_name')
                    ->minLength(1)
                    ->required(),
                Schema::string('tax_id')
                    ->pattern('^\d{2}-\d{7}$')
                    ->required()
            )),

        // Newsletter signup requirements
        'newsletter_signup' => Schema::object()
            ->if(Schema::object()->properties(
                Schema::boolean('newsletter_signup')->const(true)
            ))
            ->then(Schema::object()->properties(
                Schema::string('marketing_source')
                    ->enum(['search', 'social', 'referral', 'advertising'])
                    ->required()
            ))
    ]);

// Valid business registration with newsletter
$userRegistrationSchema->isValid([
    'username' => 'acme_corp',
    'email' => 'contact@acme.com',
    'account_type' => 'business',
    'company_name' => 'Acme Corporation',
    'tax_id' => '12-3456789',
    'newsletter_signup' => true,
    'marketing_source' => 'search'
]); // true

// Invalid business registration - missing required business fields
$userRegistrationSchema->isValid([
    'username' => 'acme_corp',
    'email' => 'contact@acme.com',
    'account_type' => 'business'
    // Missing company_name and tax_id
]); // false
```

## Complex Dependent Validation

Create sophisticated dependency chains and nested conditions:

```php
$orderSchema = Schema::object('order', SchemaVersion::Draft_2019_09)
    ->properties(
        Schema::string('type')->enum(['pickup', 'delivery']),
        Schema::boolean('requires_signature'),
        Schema::boolean('is_gift'),
        Schema::string('delivery_address'),
        Schema::string('pickup_location'),
        Schema::string('gift_message'),
        Schema::string('gift_wrap_type'),
        Schema::string('signature_instructions')
    )
    ->dependentSchemas([
        // Delivery orders need addresses
        'type' => Schema::object()
            ->if(Schema::object()->properties(
                Schema::string('type')->const('delivery')
            ))
            ->then(Schema::object()->properties(
                Schema::string('delivery_address')
                    ->minLength(10)
                    ->required()
            ))
            ->if(Schema::object()->properties(
                Schema::string('type')->const('pickup')
            ))
            ->then(Schema::object()->properties(
                Schema::string('pickup_location')
                    ->enum(['store_a', 'store_b', 'warehouse'])
                    ->required()
            )),

        // Gift orders need gift options
        'is_gift' => Schema::object()
            ->if(Schema::object()->properties(
                Schema::boolean('is_gift')->const(true)
            ))
            ->then(Schema::object()
                ->properties(
                    Schema::string('gift_message')
                        ->maxLength(200)
                        ->required(),
                    Schema::string('gift_wrap_type')
                        ->enum(['standard', 'premium', 'eco_friendly'])
                        ->required()
                )
                // Nested dependency: premium gift wrap has additional requirements
                ->dependentSchema('gift_wrap_type',
                    Schema::object()
                        ->if(Schema::object()->properties(
                            Schema::string('gift_wrap_type')->const('premium')
                        ))
                        ->then(Schema::object()
                            ->properties(
                                Schema::string('gift_message')
                                    ->minLength(10)  // Premium requires longer message
                            )
                        )
                )
            ),

        // Signature requirements
        'requires_signature' => Schema::object()
            ->if(Schema::object()->properties(
                Schema::boolean('requires_signature')->const(true)
            ))
            ->then(Schema::object()->properties(
                Schema::string('signature_instructions')
                    ->maxLength(100)
                    ->required()
            ))
    ]);
```

## Property Presence Dependencies

Simple property presence requirements without complex validation:

```php
$profileSchema = Schema::object('profile', SchemaVersion::Draft_2019_09)
    ->properties(
        Schema::string('name')->required(),
        Schema::boolean('public_email'),
        Schema::string('email'),
        Schema::boolean('show_phone'),
        Schema::string('phone'),
        Schema::boolean('enable_notifications'),
        Schema::string('notification_email')
    )
    ->dependentSchemas([
        // If public_email is true, email must be present
        'public_email' => Schema::object()
            ->if(Schema::object()->properties(
                Schema::boolean('public_email')->const(true)
            ))
            ->then(Schema::object()->properties(
                Schema::string('email')
                    ->format(SchemaFormat::Email)
                    ->required()
            )),

        // If show_phone is true, phone must be present
        'show_phone' => Schema::object()
            ->if(Schema::object()->properties(
                Schema::boolean('show_phone')->const(true)
            ))
            ->then(Schema::object()->properties(
                Schema::string('phone')
                    ->pattern('^\+\d{1,3}-\d{3,4}-\d{6,8}$')
                    ->required()
            )),

        // If notifications enabled, notification email required
        'enable_notifications' => Schema::object()
            ->if(Schema::object()->properties(
                Schema::boolean('enable_notifications')->const(true)
            ))
            ->then(Schema::object()->properties(
                Schema::string('notification_email')
                    ->format(SchemaFormat::Email)
                    ->required()
            ))
    ]);
```

## API Configuration Example

Real-world example for API endpoint configuration:

```php
$apiEndpointSchema = Schema::object('api_endpoint', SchemaVersion::Draft_2019_09)
    ->properties(
        Schema::string('path')->required(),
        Schema::string('method')->enum(['GET', 'POST', 'PUT', 'DELETE'])->required(),
        Schema::boolean('requires_auth'),
        Schema::string('auth_type')->enum(['jwt', 'api_key', 'oauth']),
        Schema::boolean('rate_limited'),
        Schema::integer('rate_limit_per_minute'),
        Schema::boolean('cache_enabled'),
        Schema::integer('cache_ttl_seconds'),
        Schema::boolean('validate_request'),
        Schema::object('request_schema'),
        Schema::boolean('transform_response'),
        Schema::object('response_transform')
    )
    ->dependentSchemas([
        // Authentication dependencies
        'requires_auth' => Schema::object()
            ->if(Schema::object()->properties(
                Schema::boolean('requires_auth')->const(true)
            ))
            ->then(Schema::object()->properties(
                Schema::string('auth_type')->required()
            )),

        // Rate limiting dependencies
        'rate_limited' => Schema::object()
            ->if(Schema::object()->properties(
                Schema::boolean('rate_limited')->const(true)
            ))
            ->then(Schema::object()->properties(
                Schema::integer('rate_limit_per_minute')
                    ->minimum(1)
                    ->maximum(10000)
                    ->required()
            )),

        // Caching dependencies
        'cache_enabled' => Schema::object()
            ->if(Schema::object()->properties(
                Schema::boolean('cache_enabled')->const(true)
            ))
            ->then(Schema::object()->properties(
                Schema::integer('cache_ttl_seconds')
                    ->minimum(60)
                    ->maximum(86400)
                    ->required()
            )),

        // Request validation dependencies
        'validate_request' => Schema::object()
            ->if(Schema::object()->properties(
                Schema::boolean('validate_request')->const(true)
            ))
            ->then(Schema::object()->properties(
                Schema::object('request_schema')
                    ->additionalProperties(true)
                    ->required()
            )),

        // Response transformation dependencies
        'transform_response' => Schema::object()
            ->if(Schema::object()->properties(
                Schema::boolean('transform_response')->const(true)
            ))
            ->then(Schema::object()->properties(
                Schema::object('response_transform')
                    ->properties(
                        Schema::string('type')->enum(['map', 'filter', 'custom'])->required(),
                        Schema::object('config')->additionalProperties(true)
                    )
                    ->required()
            ))
    ]);

// Valid API endpoint configuration
$apiEndpointSchema->isValid([
    'path' => '/api/users',
    'method' => 'POST',
    'requires_auth' => true,
    'auth_type' => 'jwt',
    'rate_limited' => true,
    'rate_limit_per_minute' => 100,
    'validate_request' => true,
    'request_schema' => [
        'type' => 'object',
        'properties' => [
            'name' => ['type' => 'string'],
            'email' => ['type' => 'string', 'format' => 'email']
        ],
        'required' => ['name', 'email']
    ]
]); // true
```

## Validation Examples

```php
use Cortex\JsonSchema\Exceptions\SchemaException;

// Test the payment schema from earlier
$paymentData = [
    'amount' => '50.00',
    'method' => 'paypal',
    'paypal_email' => 'user@example.com'
];

try {
    $paymentSchema->validate($paymentData);
    echo "Payment data is valid";
} catch (SchemaException $e) {
    echo "Validation error: " . $e->getMessage();
}

// Test with missing dependent field
$invalidPaymentData = [
    'amount' => '50.00',
    'method' => 'card'
    // Missing card_number which is required when method is 'card'
];

try {
    $paymentSchema->validate($invalidPaymentData);
} catch (SchemaException $e) {
    echo "Validation error: " . $e->getMessage();
    // "Property 'card_number' is required"
}
```

## Dependent vs Independent Schemas

### Dependent Schemas (Draft 2019-09+)

```php
// Modern approach - property-dependent validation
$modernSchema = Schema::object('user', SchemaVersion::Draft_2019_09)
    ->properties(
        Schema::boolean('has_address'),
        Schema::string('street'),
        Schema::string('city')
    )
    ->dependentSchema('has_address',
        Schema::object()
            ->if(Schema::object()->properties(
                Schema::boolean('has_address')->const(true)
            ))
            ->then(Schema::object()->properties(
                Schema::string('street')->required(),
                Schema::string('city')->required()
            ))
    );
```

### Traditional Dependencies (Draft-07)

```php
// Traditional approach - less flexible
$traditionalSchema = Schema::object('user', SchemaVersion::Draft_07)
    ->properties(
        Schema::boolean('has_address'),
        Schema::string('street'),
        Schema::string('city')
    );
    // Would need complex if/then/else logic to achieve similar behavior
```

## Performance Considerations

<Tip>
Dependent schemas are evaluated only when the triggering property is present, making them efficient for conditional validation.
</Tip>

```php
// Efficient - dependency only evaluated when 'type' is present
$efficientSchema = Schema::object('data', SchemaVersion::Draft_2019_09)
    ->properties(
        Schema::string('name')->required()
        // 'type' is optional
    )
    ->dependentSchema('type', $complexValidationSchema);

// If 'type' is not in the data, the dependent schema is not evaluated
```

## Best Practices

### 1. Use Clear Property Names for Dependencies

```php
// Good: Clear trigger property
$schema->dependentSchema('payment_method', $paymentValidation);

// Less clear: Ambiguous trigger
$schema->dependentSchema('flag', $someValidation);
```

### 2. Group Related Dependencies

```php
// Good: Logically group related dependent schemas
$schema->dependentSchemas([
    'enable_feature_a' => $featureAValidation,
    'enable_feature_b' => $featureBValidation,
    'enable_feature_c' => $featureCValidation
]);
```

### 3. Document Complex Dependencies

```php
$schema->dependentSchema('complex_option',
    Schema::object()
        ->description('When complex_option is enabled, additional validation rules apply')
        ->if(/* condition */)
        ->then(/* validation */)
);
```

### 4. Avoid Circular Dependencies

```php
// Avoid: Circular dependency chains
$schema->dependentSchemas([
    'field_a' => Schema::object()->dependentSchema('field_b', $validation),
    'field_b' => Schema::object()->dependentSchema('field_a', $validation)
]);
```

## Common Use Cases

<CardGroup cols={2}>
  <Card title="Dynamic Forms" icon="file-text">
    Forms where available fields and validation rules change based on user selections.
  </Card>
  <Card title="API Configuration" icon="cog">
    Configuration objects where certain settings require additional parameters.
  </Card>
  <Card title="Payment Processing" icon="wallet">
    Different validation rules for different payment methods and options.
  </Card>
  <Card title="User Profiles" icon="user">
    Profile settings where enabled features require additional information.
  </Card>
</CardGroup>
