---
title: From Enums
description: 'Generate validation schemas from PHP backed enums'
---

Generate JSON schemas automatically from PHP backed enums. This feature extracts enum values and creates appropriate validation schemas for string or integer enumeration validation.

## Basic Enum Schema Generation

Generate a schema from a simple string-backed enum:

```php
use Cortex\JsonSchema\Schema;

/**
 * User account status levels
 */
enum UserStatus: string
{
    case Active = 'active';
    case Inactive = 'inactive';
    case Suspended = 'suspended';
    case Pending = 'pending_verification';
}

// Generate schema from enum
$schema = Schema::fromEnum(UserStatus::class);

// Convert to JSON Schema
$jsonSchema = $schema->toJson(JSON_PRETTY_PRINT);
```

<Accordion title="View Generated JSON Schema">
```json
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "type": "string",
    "title": "UserStatus",
    "description": "User account status levels",
    "enum": [
        "active",
        "inactive",
        "suspended",
        "pending_verification"
    ]
}
```
</Accordion>

## Integer-Backed Enums

Handle integer-backed enums for numeric enumeration:

```php
/**
 * Priority levels for task management
 */
enum Priority: int
{
    case Low = 1;
    case Medium = 2;
    case High = 3;
    case Critical = 4;
    case Emergency = 5;
}

$prioritySchema = Schema::fromEnum(Priority::class);
```

<Accordion title="View Generated JSON Schema">
```json
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "type": "integer",
    "title": "Priority",
    "description": "Priority levels for task management",
    "enum": [1, 2, 3, 4, 5]
}
```
</Accordion>

## Enums with Rich Documentation

Create comprehensive documentation using docblocks:

```php
/**
 * Payment processing status
 *
 * Represents the current state of a payment transaction
 * in the payment processing pipeline.
 */
enum PaymentStatus: string
{
    /**
     * Payment has been initiated but not yet processed
     */
    case Pending = 'pending';

    /**
     * Payment is currently being processed by the payment gateway
     */
    case Processing = 'processing';

    /**
     * Payment has been successfully completed
     */
    case Completed = 'completed';

    /**
     * Payment failed due to insufficient funds or other issues
     */
    case Failed = 'failed';

    /**
     * Payment was cancelled by the user or system
     */
    case Cancelled = 'cancelled';

    /**
     * Payment was refunded to the customer
     */
    case Refunded = 'refunded';
}

$paymentSchema = Schema::fromEnum(PaymentStatus::class);
```

## Schema Version Support

Generate enums with specific JSON Schema versions:

```php
use Cortex\JsonSchema\Enums\SchemaVersion;

/**
 * Order fulfillment status
 */
enum OrderStatus: string
{
    case Draft = 'draft';
    case Confirmed = 'confirmed';
    case Processing = 'processing';
    case Shipped = 'shipped';
    case Delivered = 'delivered';
    case Cancelled = 'cancelled';

    /**
     * @deprecated Use 'cancelled' instead
     */
    case Rejected = 'rejected';
}

// Generate with Draft 2019-09 for deprecated support
$schema = Schema::fromEnum(
    OrderStatus::class,
    version: SchemaVersion::Draft_2019_09
);

// The generated schema can include deprecation information for specific values
```

## Complex Business Enums

Real-world examples with business logic representation:

```php
/**
 * E-commerce product category classification
 *
 * Categories used for product organization, filtering,
 * and recommendation algorithms.
 */
enum ProductCategory: string
{
    case Electronics = 'electronics';
    case Clothing = 'clothing_apparel';
    case HomeGarden = 'home_garden';
    case SportsOutdoors = 'sports_outdoors';
    case BooksMedia = 'books_media';
    case ToysGames = 'toys_games';
    case HealthBeauty = 'health_beauty';
    case Automotive = 'automotive';
    case GroceryFood = 'grocery_food';
    case Office = 'office_supplies';
}

/**
 * Shipping method options
 */
enum ShippingMethod: string
{
    case Standard = 'standard';
    case Express = 'express';
    case Overnight = 'overnight';
    case TwoDay = 'two_day';
    case SameDay = 'same_day';
    case Pickup = 'store_pickup';
    case Digital = 'digital_delivery';
}

/**
 * Customer service ticket priority
 */
enum TicketPriority: int
{
    case Low = 10;
    case Normal = 20;
    case High = 30;
    case Urgent = 40;
    case Critical = 50;
}

// Generate schemas for each enum
$categorySchema = Schema::fromEnum(ProductCategory::class);
$shippingSchema = Schema::fromEnum(ShippingMethod::class);
$prioritySchema = Schema::fromEnum(TicketPriority::class);
```

## Enums in Object Schemas

Use generated enum schemas within larger object schemas:

```php
/**
 * User role in the system
 */
enum UserRole: string
{
    case Admin = 'admin';
    case Manager = 'manager';
    case Employee = 'employee';
    case Customer = 'customer';
    case Guest = 'guest';
}

/**
 * Account verification status
 */
enum VerificationStatus: string
{
    case Unverified = 'unverified';
    case Pending = 'pending';
    case Verified = 'verified';
    case Rejected = 'rejected';
}

// Create object schema that uses enum schemas
$userAccountSchema = Schema::object('user_account')
    ->properties(
        Schema::string('id')->required(),
        Schema::string('username')->required(),
        Schema::string('email')->required(),

        // Use enum schemas for validation
        Schema::fromEnum(UserRole::class)
            ->propertyName('role')
            ->required(),

        Schema::fromEnum(VerificationStatus::class)
            ->propertyName('verification_status')
            ->default('unverified'),

        Schema::fromEnum(UserStatus::class)
            ->propertyName('status')
            ->default('pending_verification')
    );

// Validate user account data
$userAccountSchema->isValid([
    'id' => 'user_123',
    'username' => 'john_doe',
    'email' => 'john@example.com',
    'role' => 'employee',
    'verification_status' => 'verified',
    'status' => 'active'
]); // true
```

## API Response Enum Generation

Create enums for API response codes and statuses:

```php
/**
 * HTTP-style API response codes
 */
enum ApiResponseCode: int
{
    case Success = 200;
    case Created = 201;
    case Accepted = 202;
    case NoContent = 204;
    case BadRequest = 400;
    case Unauthorized = 401;
    case Forbidden = 403;
    case NotFound = 404;
    case MethodNotAllowed = 405;
    case Conflict = 409;
    case ValidationError = 422;
    case InternalServerError = 500;
    case ServiceUnavailable = 503;
}

/**
 * API operation result status
 */
enum OperationStatus: string
{
    case Success = 'success';
    case Partial = 'partial_success';
    case Failed = 'failed';
    case Timeout = 'timeout';
    case Cancelled = 'cancelled';
}

/**
 * Data validation result
 */
enum ValidationResult: string
{
    case Valid = 'valid';
    case Invalid = 'invalid';
    case Warning = 'warning';
    case Skipped = 'skipped';
}

// Create comprehensive API response schema
$apiResponseSchema = Schema::object('api_response')
    ->properties(
        Schema::fromEnum(ApiResponseCode::class)
            ->propertyName('code')
            ->required(),

        Schema::fromEnum(OperationStatus::class)
            ->propertyName('status')
            ->required(),

        Schema::string('message'),

        Schema::object('data')
            ->additionalProperties(true),

        Schema::array('validation_results')
            ->items(
                Schema::object()
                    ->properties(
                        Schema::string('field')->required(),
                        Schema::fromEnum(ValidationResult::class)
                            ->propertyName('result')
                            ->required(),
                        Schema::string('message')
                    )
            )
    );
```

## Configuration Enums

Use enums for application configuration validation:

```php
/**
 * Application environment types
 */
enum Environment: string
{
    case Development = 'development';
    case Testing = 'testing';
    case Staging = 'staging';
    case Production = 'production';
}

/**
 * Logging levels based on PSR-3
 */
enum LogLevel: string
{
    case Emergency = 'emergency';
    case Alert = 'alert';
    case Critical = 'critical';
    case Error = 'error';
    case Warning = 'warning';
    case Notice = 'notice';
    case Info = 'info';
    case Debug = 'debug';
}

/**
 * Cache driver options
 */
enum CacheDriver: string
{
    case Redis = 'redis';
    case Memcached = 'memcached';
    case File = 'file';
    case Database = 'database';
    case Memory = 'array';
}

/**
 * Database connection types
 */
enum DatabaseDriver: string
{
    case MySQL = 'mysql';
    case PostgreSQL = 'pgsql';
    case SQLite = 'sqlite';
    case SQLServer = 'sqlsrv';
}

// Application configuration schema
$configSchema = Schema::object('app_config')
    ->properties(
        Schema::string('app_name')->required(),

        Schema::fromEnum(Environment::class)
            ->propertyName('environment')
            ->required(),

        Schema::fromEnum(LogLevel::class)
            ->propertyName('log_level')
            ->default('info'),

        Schema::object('cache')
            ->properties(
                Schema::fromEnum(CacheDriver::class)
                    ->propertyName('driver')
                    ->default('file'),
                Schema::integer('ttl')
                    ->minimum(60)
                    ->default(3600)
            ),

        Schema::object('database')
            ->properties(
                Schema::fromEnum(DatabaseDriver::class)
                    ->propertyName('driver')
                    ->required(),
                Schema::string('host')->required(),
                Schema::integer('port')
                    ->minimum(1)
                    ->maximum(65535),
                Schema::string('database')->required()
            )
            ->required()
    );
```

## Validation Examples

Validate data against enum schemas:

```php
// Single enum validation
$statusSchema = Schema::fromEnum(UserStatus::class);

// Test various values
$statusSchema->isValid('active');           // true
$statusSchema->isValid('pending_verification'); // true
$statusSchema->isValid('invalid_status');   // false
$statusSchema->isValid(123);                // false (wrong type)

// Priority enum validation
$prioritySchema = Schema::fromEnum(Priority::class);

$prioritySchema->isValid(1);                // true (Low)
$prioritySchema->isValid(5);                // true (Emergency)
$prioritySchema->isValid(10);               // false (not in enum)
$prioritySchema->isValid('high');           // false (wrong type)

// Complex object validation with enums
$taskData = [
    'title' => 'Fix critical bug',
    'description' => 'Address security vulnerability',
    'priority' => 4,                         // Critical
    'status' => 'active',
    'assigned_role' => 'employee'
];

$taskSchema = Schema::object('task')
    ->properties(
        Schema::string('title')->required(),
        Schema::string('description'),
        Schema::fromEnum(Priority::class)
            ->propertyName('priority')
            ->required(),
        Schema::fromEnum(UserStatus::class)
            ->propertyName('status')
            ->default('pending_verification'),
        Schema::fromEnum(UserRole::class)
            ->propertyName('assigned_role')
            ->required()
    );

try {
    $taskSchema->validate($taskData);
    echo "Task data is valid";
} catch (SchemaException $e) {
    echo "Validation error: " . $e->getMessage();
}
```

## Dynamic Enum Handling

Work with enums dynamically in applications:

```php
/**
 * Get all possible values from an enum schema
 */
function getEnumValues(string $enumClass): array
{
    $schema = Schema::fromEnum($enumClass);
    $schemaArray = $schema->toArray();

    return $schemaArray['enum'] ?? [];
}

/**
 * Validate enum value and provide suggestions
 */
function validateEnumWithSuggestions(string $enumClass, mixed $value): array
{
    $schema = Schema::fromEnum($enumClass);

    if ($schema->isValid($value)) {
        return ['valid' => true, 'suggestions' => []];
    }

    $validValues = getEnumValues($enumClass);
    $suggestions = [];

    // Find similar values (simple string similarity)
    if (is_string($value)) {
        foreach ($validValues as $validValue) {
            if (is_string($validValue) &&
                levenshtein($value, $validValue) <= 2) {
                $suggestions[] = $validValue;
            }
        }
    }

    return [
        'valid' => false,
        'suggestions' => $suggestions,
        'valid_values' => $validValues
    ];
}

// Usage examples
$priorityValues = getEnumValues(Priority::class);
// Returns: [1, 2, 3, 4, 5]

$validation = validateEnumWithSuggestions(UserStatus::class, 'activ');
// Returns: ['valid' => false, 'suggestions' => ['active'], 'valid_values' => [...]]

$validation = validateEnumWithSuggestions(Priority::class, 3);
// Returns: ['valid' => true, 'suggestions' => []]
```

## Form Generation from Enums

Generate HTML form options from enum schemas:

```php
/**
 * Generate HTML select options from enum
 */
function generateSelectOptions(string $enumClass, ?string $selected = null): string
{
    $schema = Schema::fromEnum($enumClass);
    $schemaArray = $schema->toArray();
    $enumValues = $schemaArray['enum'] ?? [];

    $options = [];
    foreach ($enumValues as $value) {
        $isSelected = ($value === $selected) ? ' selected' : '';
        $label = ucfirst(str_replace(['_', '-'], ' ', (string)$value));
        $options[] = "<option value=\"{$value}\"{$isSelected}>{$label}</option>";
    }

    return implode("\n", $options);
}

/**
 * Generate form validation rules for frontend
 */
function generateValidationRules(string $enumClass): array
{
    $schema = Schema::fromEnum($enumClass);
    $schemaArray = $schema->toArray();

    return [
        'type' => $schemaArray['type'],
        'enum' => $schemaArray['enum'],
        'required' => true,
        'message' => "Must be one of: " . implode(', ', $schemaArray['enum'])
    ];
}

// Usage
echo "<select name=\"priority\">\n";
echo generateSelectOptions(Priority::class, 2); // Medium selected
echo "\n</select>";

$validationRules = generateValidationRules(UserStatus::class);
// For frontend JavaScript validation
```

## Best Practices

### 1. Use Descriptive Enum Names and Values

```php
// Good: Clear, descriptive names
enum OrderStatus: string
{
    case PendingPayment = 'pending_payment';
    case PaymentConfirmed = 'payment_confirmed';
    case InFulfillment = 'in_fulfillment';
    case Shipped = 'shipped';
    case Delivered = 'delivered';
}

// Avoid: Unclear or abbreviated names
enum Status: string
{
    case P = 'p';
    case C = 'c';
    case S = 's';
}
```

### 2. Document Business Logic

```php
/**
 * Customer service ticket severity levels
 *
 * Used to prioritize support tickets and determine
 * response time requirements.
 */
enum TicketSeverity: int
{
    /** General questions - 48h response time */
    case Low = 1;

    /** Account issues - 24h response time */
    case Medium = 2;

    /** Service disruption - 4h response time */
    case High = 3;

    /** Security issues - 1h response time */
    case Critical = 4;
}
```

### 3. Consider Backward Compatibility

```php
/**
 * API version identifiers
 */
enum ApiVersion: string
{
    case V1 = 'v1';
    case V2 = 'v2';
    case V3 = 'v3';

    /** @deprecated Use V3 instead */
    case V2_Legacy = 'v2-legacy';
}
```

### 4. Use Appropriate Backing Types

```php
// Good: String for human-readable values
enum NotificationType: string
{
    case Email = 'email';
    case SMS = 'sms';
    case Push = 'push_notification';
}

// Good: Integer for ordered values
enum AccessLevel: int
{
    case Guest = 1;
    case User = 10;
    case Moderator = 50;
    case Admin = 100;
}
```

## Error Handling

Handle enum validation errors gracefully:

```php
function processUserRole(string $roleValue): void
{
    $roleSchema = Schema::fromEnum(UserRole::class);

    try {
        $roleSchema->validate($roleValue);
        echo "Processing user with role: {$roleValue}";
    } catch (SchemaException $e) {
        $validRoles = getEnumValues(UserRole::class);
        throw new InvalidArgumentException(
            "Invalid role '{$roleValue}'. Valid roles are: " .
            implode(', ', $validRoles)
        );
    }
}

// Usage
try {
    processUserRole('admin');        // Success
    processUserRole('invalid_role'); // Throws exception with helpful message
} catch (InvalidArgumentException $e) {
    echo "Error: " . $e->getMessage();
}
```

## Common Use Cases

<CardGroup cols={2}>
  <Card title="API Validation" icon="server">
    Validate API request parameters and response codes using enumerated values.
  </Card>
  <Card title="Configuration" icon="gear">
    Ensure application configuration uses only valid environment and option values.
  </Card>
  <Card title="State Management" icon="state-machine">
    Validate state transitions and status changes in business workflows.
  </Card>
  <Card title="Form Validation" icon="file-text">
    Generate client-side validation and form options from backend enums.
  </Card>
</CardGroup>

## Next Steps

<CardGroup cols={2}>
  <Card
    title="From JSON Schema"
    icon="file-code"
    href="/code-generation/from-json"
  >
    Import and work with existing JSON Schema definitions
  </Card>
  <Card
    title="Data Validation"
    icon="check-circle"
    href="/validation/data-validation"
  >
    Learn advanced validation techniques for enum values
  </Card>
</CardGroup>
